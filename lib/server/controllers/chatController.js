// controllers/chatController.js
const Chat = require('../models/chat');
const Message = require('../models/message');
const Media = require('../models/media');
const User = require('../models/user');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;

const createOrGetChat = async (req, res) => {
    try {
      const { participantId } = req.body;
      const userId = req.user; // Set by auth middleware
  
      console.log('Creating chat - userId:', userId);
      console.log('Creating chat - participantId:', participantId);
  
      if (!mongoose.Types.ObjectId.isValid(participantId)) {
        return res.status(400).json({ error: 'Invalid participant ID format' });
      }
  
      // Find if chat exists
      const existingChat = await Chat.findOne({
        type: 'individual',
        'participants.userId': {
          $all: [userId, participantId],
        },
      }).populate('participants.userId', 'name avatar isOnline lastSeen');
  
      if (existingChat) {
        return res.status(200).json(existingChat);
      }
  
      // Create new chat
      const newChat = new Chat({
        participants: [
          {
            userId: userId,
            role: 'admin',
            joinedAt: new Date(),
          },
          {
            userId: participantId,
            role: 'member',
            joinedAt: new Date(),
          },
        ],
        type: 'individual',
        createdAt: new Date(),
        settings: {
          onlyAdminsCanMessage: false,
          onlyAdminsCanEditInfo: true,
        },
      });
  
      await newChat.save();
      await newChat.populate('participants.userId', 'name avatar isOnline lastSeen');
  
      res.status(201).json(newChat);
    } catch (error) {
      console.error('Chat creation error:', error);
      res.status(500).json({ error: error.message });
    }
  };

  
// Get user's chats
const getUserChats = async (req, res) => {
    try {
        const userId = req.user.id;

        const chats = await Chat.find({
            participants: userId
        })
        .populate('participants', 'name avatar isOnline lastSeen')
        .populate({
            path: 'lastMessage',
            populate: {
                path: 'sender',
                select: 'name'
            }
        })
        .sort({ updatedAt: -1 });

        res.status(200).json(chats);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};

// Send message
const sendMessage = async (req, res) => {
    try {
        const {
            chatId,
            content,
            messageType = 'text',
            quotedMessageId,
            forwardedMessageId,
            senderId
        } = req.body;

        if (!senderId) {
            return res.status(400).json({ error: 'Sender ID is required' });
        }

        // Validate chat exists
        const chat = await Chat.findById(chatId);
        if (!chat) {
            return res.status(404).json({ error: 'Chat not found' });
        }

        // Create message content based on type
        const messageContent = {
            text: messageType === 'text' ? content : null,
            mediaUrl: ['image', 'video', 'audio', 'document']
                .includes(messageType) ? content : null,
            thumbnail: req.body.thumbnail || null,
            fileName: req.body.fileName || null,
            fileSize: req.body.fileSize || null,
            duration: req.body.duration || null,
            contactInfo: req.body.contactInfo || null
        };

        // Base message data matching schema
        const messageData = {
            // messageId will be automatically generated by the schema
            chatId,
            senderId,
            type: messageType,
            content: messageContent,
            replyTo: quotedMessageId || null,
            forwardedFrom: forwardedMessageId || null,
            readBy: [],
            deliveredTo: [],
            status: 'sent',
            reactions: [],
            isDeleted: false,
            deletedFor: []
        };

        // Validate quoted message if provided
        if (quotedMessageId) {
            const quotedMessage = await Message.findById(quotedMessageId);
            if (!quotedMessage) {
                return res.status(404).json({ error: 'Quoted message not found' });
            }

            if (quotedMessage.chatId.toString() !== chatId) {
                return res.status(400).json({ error: 'Quoted message must be from the same chat' });
            }
        }

        // Create and save the message
        const newMessage = await Message.create(messageData);

        if (!newMessage) {
            throw new Error('Failed to save message');
        }

        // Update chat's last message
        await Chat.findByIdAndUpdate(chatId, {
            lastMessage: newMessage._id
        });

        // Populate necessary fields for response
        const populatedMessage = await Message.findById(newMessage._id)
            .populate('replyTo')
            .populate('forwardedFrom');

        res.status(201).json(populatedMessage);

    } catch (error) {
        console.error('Error in sendMessage:', error);
        res.status(500).json({ error: error.message });
    }
};

// get the users info by number
// Node.js/Express server code
const getUsersByPhoneNumbers = async (req, res) => {
    try {
        console.log('ðŸ“© Received request body:', req.body);
        const { phoneNumbers } = req.body;
        
        // Validate input
        if (!Array.isArray(phoneNumbers) || phoneNumbers.length === 0) {
            console.log('âŒ Invalid input: phoneNumbers is not an array or is empty');
            return res.status(400).json({ error: "Please provide an array of phone numbers" });
        }
        
        console.log('ðŸ” Searching for phone numbers:', phoneNumbers);
        
        // Normalize phone numbers for comparison
        const normalizedPhoneNumbers = phoneNumbers.map(number => 
            number.replace(/[\s\(\)-]/g, '')
        );
        
        console.log('ðŸ“± Normalized phone numbers:', normalizedPhoneNumbers);
        
        // Find users with matching phone numbers
        const users = await User.find({
            number: { $in: normalizedPhoneNumbers }
        })
        .select('name username avatar isOnline lastSeen createdAt number')
        .sort({ name: 1 });
        
        console.log(`âœ… Found ${users.length} users`);
        console.log('ðŸ‘¥ Users:', users.map(u => ({ 
            name: u.name, 
            number: u.number 
        })));
        
        // Return found users
        res.status(200).json(users);
    } catch (error) {
        console.error('âŒ Error in getUsersByPhoneNumbers:', error);
        res.status(500).json({ error: error.message });
    }
};


// Get chat messages
// const getChatMessages = async (req, res) => {
//     try {
//         const { chatId } = req.params;
//         const { page = 1, limit = 50 } = req.query;
//         const userId = req.user.id;

//         const messages = await Message.find({
//             chatId,
//             deletedFor: { $ne: userId }
//         })
//         .sort({ createdAt: -1 })
//         .skip((page - 1) * limit)
//         .limit(parseInt(limit))
//         .populate('sender', 'name avatar');

//         res.status(200).json({
//             messages,
//             hasMore: messages.length === parseInt(limit)
//         });
//     } catch (error) {
//         res.status(500).json({ error: error.message });
//     }
// };

// Server-side code
const getChatMessages = async (req, res) => {
    try {
        const { chatId } = req.params;
        const { page = 1, limit = 50 } = req.query;
        const userId = req.user.id;

        // Find messages that aren't deleted for the requesting user
        const messages = await Message.find({
            chatId,
            $or: [
                { isDeleted: false },
                { isDeleted: true, deletedFor: { $ne: userId } }
            ]
        })
        .sort({ createdAt: -1 })
        .skip((page - 1) * limit)
        .limit(parseInt(limit))
        .lean();

        // Format messages according to the Message model
        const formattedMessages = messages.map(msg => ({
            messageId: msg._id.toString(),
            chatId: msg.chatId,
            senderId: msg.senderId,
            type: msg.type,
            content: {
                text: msg.content.text,
                mediaUrl: msg.content.mediaUrl,
                thumbnail: msg.content.thumbnail,
                fileName: msg.content.fileName,
                fileSize: msg.content.fileSize,
                duration: msg.content.duration,
                contactInfo: msg.content.contactInfo
            },
            replyTo: msg.replyTo,
            forwardedFrom: msg.forwardedFrom,
            readBy: msg.readBy,
            deliveredTo: msg.deliveredTo,
            status: msg.status,
            createdAt: msg.createdAt,
            reactions: msg.reactions,
            isDeleted: msg.isDeleted,
            deletedFor: msg.deletedFor
        }));

        res.status(200).json({
            messages: formattedMessages,
            hasMore: messages.length === parseInt(limit)
        });
    } catch (error) {
        console.error('Error fetching messages:', error);
        res.status(500).json({ error: error.message });
    }
};

// Mark messages as read
const markMessagesAsRead = async (req, res) => {
    try {
        const { chatId } = req.params;
        const userId = req.user.id;

        await Message.updateMany(
            { chatId, sender: { $ne: userId } },
            { $addToSet: { readBy: userId } }
        );

        await Chat.findByIdAndUpdate(chatId, {
            $set: { [`unreadCounts.${userId}`]: 0 }
        });

        res.status(200).json({ success: true });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};

// Delete message
const deleteMessage = async (req, res) => {
    try {
        const { messageId } = req.params;
        const userId = req.user.id;

        await Message.findByIdAndUpdate(messageId, {
            $addToSet: { deletedFor: userId }
        });

        res.status(200).json({ success: true });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};

module.exports = {
    createOrGetChat,
    getUserChats,
    getChatMessages,
    sendMessage,
    getUsersByPhoneNumbers,
    markMessagesAsRead,
    deleteMessage
};


// POST /chat - Create or get one-to-one chat
// exports.createOrGetChat = async (req, res) => {
//     try {
//         const { participantId } = req.body;
//         const userId = req.user.id;

//         // Check if chat already exists
//         const existingChat = await Chat.findOne({
//             chatType: 'individual',
//             participants: {
//                 $all: [userId, participantId]
//             }
//         }).populate('participants', 'name avatar isOnline lastSeen');

//         if (existingChat) {
//             return res.status(200).json(existingChat);
//         }

//         // Verify participant exists
//         const participant = await User.findById(participantId);
//         if (!participant) {
//             return res.status(404).json({ error: 'Participant not found' });
//         }

//         // Create new chat
//         const newChat = new Chat({
//             participants: [userId, participantId],
//             chatType: 'individual',
//             unreadCounts: new Map([[participantId, 0], [userId, 0]]),
//             meta: new Map([
//                 [userId, { archived: false, muted: false }],
//                 [participantId, { archived: false, muted: false }]
//             ])
//         });

//         await newChat.save();
//         await newChat.populate('participants', 'name avatar isOnline lastSeen');
        
//         res.status(201).json(newChat);
//     } catch (error) {
//         res.status(500).json({ error: error.message });
//     }
// };

// // GET /chats - Get all user's chats
// exports.getUserChats = async (req, res) => {
//     try {
//         const userId = req.user.id;

//         const chats = await Chat.find({
//             participants: userId
//         })
//         .populate('participants', 'name avatar isOnline lastSeen')
//         .populate({
//             path: 'lastMessage',
//             populate: {
//                 path: 'sender',
//                 select: 'name'
//             }
//         })
//         .sort({ updatedAt: -1 });

//         const formattedChats = chats.map(chat => {
//             const otherParticipant = chat.participants.find(
//                 p => p._id.toString() !== userId.toString()
//             );
            
//             return {
//                 _id: chat._id,
//                 participant: otherParticipant,
//                 lastMessage: chat.lastMessage,
//                 unreadCount: chat.unreadCounts.get(userId.toString()) || 0,
//                 updatedAt: chat.updatedAt,
//                 meta: chat.meta.get(userId.toString()) || {}
//             };
//         });

//         res.status(200).json(formattedChats);
//     } catch (error) {
//         res.status(500).json({ error: error.message });
//     }
// };

// // POST /chat/message - Send a new message
// exports.sendMessage = async (req, res) => {
//     try {
//         const { chatId, content, messageType = 'text', quotedMessageId } = req.body;
//         const senderId = req.user.id;

//         const session = await mongoose.startSession();
//         session.startTransaction();

//         try {
//             // Verify chat exists and user is participant
//             const chat = await Chat.findOne({
//                 _id: chatId,
//                 participants: senderId
//             });

//             if (!chat) {
//                 await session.abortTransaction();
//                 return res.status(404).json({ error: 'Chat not found' });
//             }

//             // Create message
//             const newMessage = new Message({
//                 chatId,
//                 sender: senderId,
//                 messageType,
//                 content: {
//                     text: messageType === 'text' ? content : null,
//                     mediaUrl: messageType !== 'text' ? content : null
//                 },
//                 status: 'sent',
//                 deliveredTo: [],
//                 readBy: []
//             });

//             if (quotedMessageId) {
//                 const quotedMessage = await Message.findById(quotedMessageId);
//                 if (quotedMessage) {
//                     newMessage.quotedMessage = {
//                         messageId: quotedMessageId,
//                         content: quotedMessage.content.text || 'Media message',
//                         type: quotedMessage.messageType
//                     };
//                 }
//             }

//             await newMessage.save({ session });

//             // Update chat
//             const otherParticipants = chat.participants.filter(
//                 p => p.toString() !== senderId.toString()
//             );

//             otherParticipants.forEach(participantId => {
//                 const currentCount = chat.unreadCounts.get(participantId.toString()) || 0;
//                 chat.unreadCounts.set(participantId.toString(), currentCount + 1);
//             });

//             chat.lastMessage = newMessage._id;
//             chat.updatedAt = new Date();
//             await chat.save({ session });

//             await session.commitTransaction();

//             // Populate message details
//             await newMessage.populate('sender', 'name avatar');

//             // Emit socket events
//             otherParticipants.forEach(participantId => {
//                 if (clients[participantId]) {
//                     clients[participantId].emit('new_message', {
//                         message: newMessage,
//                         chat: chat._id
//                     });
//                 }
//             });

//             res.status(201).json(newMessage);
//         } catch (error) {
//             await session.abortTransaction();
//             throw error;
//         } finally {
//             session.endSession();
//         }
//     } catch (error) {
//         res.status(500).json({ error: error.message });
//     }
// };

// // GET /chat/:chatId/messages - Get messages for a specific chat
// exports.getChatMessages = async (req, res) => {
//     try {
//         const { chatId } = req.params;
//         const { page = 1, limit = 50 } = req.query;
//         const userId = req.user.id;

//         // Verify user is participant
//         const chat = await Chat.findOne({
//             _id: chatId,
//             participants: userId
//         });

//         if (!chat) {
//             return res.status(404).json({ error: 'Chat not found' });
//         }

//         const messages = await Message.find({
//             chatId,
//             deletedFor: { $ne: userId }
//         })
//         .sort({ createdAt: -1 })
//         .skip((page - 1) * limit)
//         .limit(parseInt(limit))
//         .populate('sender', 'name avatar')
//         .populate({
//             path: 'quotedMessage.messageId',
//             populate: {
//                 path: 'sender',
//                 select: 'name'
//             }
//         });

//         // Mark messages as delivered
//         const undeliveredMessages = messages.filter(
//             msg => msg.sender.toString() !== userId.toString() &&
//             !msg.deliveredTo.some(delivery => delivery.user.toString() === userId.toString())
//         );

//         if (undeliveredMessages.length > 0) {
//             await Message.updateMany(
//                 { _id: { $in: undeliveredMessages.map(msg => msg._id) } },
//                 {
//                     $push: {
//                         deliveredTo: {
//                             user: userId,
//                             deliveredAt: new Date()
//                         }
//                     }
//                 }
//             );

//             // Notify senders about delivery
//             undeliveredMessages.forEach(msg => {
//                 if (clients[msg.sender.toString()]) {
//                     clients[msg.sender.toString()].emit('message_delivered', {
//                         messageId: msg._id,
//                         deliveredTo: userId,
//                         chatId: chatId
//                     });
//                 }
//             });
//         }

//         res.status(200).json({
//             messages,
//             hasMore: messages.length === parseInt(limit)
//         });
//     } catch (error) {
//         res.status(500).json({ error: error.message });
//     }
// };

// // PUT /chat/:chatId/read - Mark messages as read
// exports.markMessagesAsRead = async (req, res) => {
//     try {
//         const { chatId } = req.params;
//         const userId = req.user.id;

//         // Update messages
//         const updatedMessages = await Message.updateMany(
//             {
//                 chatId,
//                 sender: { $ne: userId },
//                 'readBy.user': { $ne: userId }
//             },
//             {
//                 $push: {
//                     readBy: {
//                         user: userId,
//                         readAt: new Date()
//                     }
//                 }
//             }
//         );

//         // Reset unread count
//         await Chat.findByIdAndUpdate(chatId, {
//             $set: {
//                 [`unreadCounts.${userId}`]: 0
//             }
//         });

//         // Notify other participants
//         const chat = await Chat.findById(chatId);
//         if (chat) {
//             chat.participants.forEach(participantId => {
//                 if (participantId.toString() !== userId.toString() && clients[participantId]) {
//                     clients[participantId].emit('messages_read', {
//                         chatId,
//                         readBy: userId,
//                         readAt: new Date()
//                     });
//                 }
//             });
//         }

//         res.status(200).json({ success: true });
//     } catch (error) {
//         res.status(500).json({ error: error.message });
//     }
// };

// // DELETE /message/:messageId - Delete a message
// exports.deleteMessage = async (req, res) => {
//     try {
//         const { messageId } = req.params;
//         const userId = req.user.id;

//         const message = await Message.findById(messageId);
//         if (!message) {
//             return res.status(404).json({ error: 'Message not found' });
//         }

//         // Add user to deletedFor array
//         if (!message.deletedFor.includes(userId)) {
//             message.deletedFor.push(userId);
//             await message.save();

//             // If this was the last message in chat, update chat.lastMessage
//             const chat = await Chat.findById(message.chatId);
//             if (chat && chat.lastMessage.toString() === messageId) {
//                 const lastMessage = await Message.findOne({
//                     chatId: chat._id,
//                     deletedFor: { $ne: userId },
//                     _id: { $ne: messageId }
//                 })
//                 .sort({ createdAt: -1 });

//                 chat.lastMessage = lastMessage ? lastMessage._id : null;
//                 await chat.save();
//             }
//         }

//         res.status(200).json({ success: true });
//     } catch (error) {
//         res.status(500).json({ error: error.message });
//     }
// };